@app.get("/api/auto-stream")
async def get_auto_stream(movie_url: str):
    """
    Automatically resolve the best quality stream for a movie.
    Prefers 1080p > 720p > other qualities.
    Refined to pick the LARGEST file size at the final level.
    """
    try:
        # 1. Get qualities (Level 3)
        data = await scraper.get_qualities(movie_url)
        qualities = data.get('qualities', [])
        
        if not qualities:
            raise HTTPException(status_code=404, detail="No qualities found")
        
        # 2. Sort by quality preference (Level 3)
        quality_priority = ['1080', '720', '640', '480', 'original', 'hd']
        selected_quality = None
        
        for priority in quality_priority:
            for q in qualities:
                if priority in q['name'].lower():
                    selected_quality = q
                    break
            if selected_quality:
                break
        
        if not selected_quality:
             selected_quality = qualities[0]

        print(f"Selected Quality: {selected_quality['name']}")
        
        # 3. Get files (Level 4)
        files = await scraper.get_files(selected_quality['link'])
        if not files:
            raise HTTPException(status_code=404, detail="No files found")
        
        # Sort Level 4 by Resolution Priority
        non_sample_files = [f for f in files if "sample" not in f['name'].lower()]
        candidates_l4 = non_sample_files if non_sample_files else files
        
        l4_priority = ['1080', '720', '640', '480', 'original', 'hd'] 
        selected_file = None
        
        for priority in l4_priority:
            for f in candidates_l4:
                if priority in f['name'].lower():
                    selected_file = f
                    break
            if selected_file:
                break
        
        if not selected_file:
            selected_file = candidates_l4[0]
        
        print(f"Selected File (Level 4): {selected_file['name']}")
        
        # 4. Get Servers (Level 5) - UPDATED SORTING LOGIC
        servers = await scraper.get_servers(selected_file['link'])
        if not servers:
            raise HTTPException(status_code=404, detail="No servers found")

        # Filter out samples
        non_sample_servers = [s for s in servers if "sample" not in s['server'].lower()]
        candidates_l5 = non_sample_servers if non_sample_servers else servers
        
        # --- NEW SIZE SORTER START ---
        import re
        
        def parse_size_mb(text):
            """Extracts size (e.g. '2.4 GB') and converts to MB for comparison."""
            # Matches number followed by optional space and GB/MB
            match = re.search(r'(\d+(?:\.\d+)?)\s*(GB|MB)', text, re.IGNORECASE)
            if not match:
                return 0.0 # Treat unknown size as smallest
            
            val = float(match.group(1))
            unit = match.group(2).upper()
            
            if unit == 'GB':
                return val * 1024 # Convert GB to MB
            return val # MB is base
            
        # Select the server with the maximum file size
        target_server = max(candidates_l5, key=lambda s: parse_size_mb(s['server']))
        # --- NEW SIZE SORTER END ---
        
        print(f"Selected Server/File: {target_server['server']} (Size-Optimized)")

        # 5. Get Stream Link
        final_link = await scraper.resolve_final_link(target_server['link'], depth=0)
        
        if not final_link:
            raise HTTPException(status_code=404, detail="Could not resolve final link")
        
        return {
            "stream_url": final_link,
            "quality": selected_quality['name'],
            "filename": selected_file['name'],
            "server_label": target_server['server'],
            "poster": data.get('meta', {}).get('poster'),
            "desc": data.get('meta', {}).get('desc')
        }
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error in auto-stream: {e}")
        raise HTTPException(status_code=500, detail=str(e))
